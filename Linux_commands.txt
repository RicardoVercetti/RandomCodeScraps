Linux Commands & Shortcuts

systemctl
  [System state management]
  - systemctl reboot                                                  # Restart the machine.
  - systemctl poweroff                                                # Power off the system.
  - systemctl suspend                                                 # Suspend the system to RAM (low power mode).
  - systemctl halt                                                    # Halt the system without powering off.
  - systemctl rescue                                                  # Enter rescue (single-user) mode.
  - systemctl isolate <target>                                        # Switch to a specific system target (e.g., graphical).
  [Service management]
  - systemctl isolate multi-user.target                               # Switch to multi-user (non-graphical) mode.
  - systemctl start <service>                                         # Start a service manually.
  - systemctl stop <service>                                          # Stop a running service.
  - systemctl restart <service>                                       # Restart a service (stop and start again).
  - systemctl reload <service>                                        # Reload configuration without stopping the service (if supported).
  - systemctl status <service>                                        # Show the current status of a service.
  - systemctl enable <service>                                        # Enable the service to start at boot.
  - systemctl disable <service>                                       # Disable the service from starting at boot.
  - systemctl is-active <service>                                     # Check if the service is active (running).
  - systemctl list-jobs                                               # list all systemctl services that are not in the process of starting up
  - systemctl is-enabled <service>                                    # Check if the service is enabled at boot.
  - systemctl list-units --type=service --state=running				  # all running services
  - systemctl --user list-units --type=service --state=running		  # user service
  - sudo systemctl list-unit-files | grep -i tomcat					  # find from files
  [analyze]
  - systemd-analyze											# Show overall boot performance summary
  - systemd-analyze blame										# Show detailed per-service startup times
  - systemd-analyze critical-chain									# Visualize startup sequence (timeline view)
  - systemd-analyze plot > boot.svg


journalctl
 - journalctl							# all logs from the oldest to newest
 - journalctl -b 0 						# 0 → current boot(optinal), 1 → previous boot
 - journalctl --list-boots				# shows all boots including 0(from above)
 - journalctl -n 50						# last 50
 - journalctl -f						# live logs like `tail -f`
 - journalctl -u <service_name>					# -u filters by systemd service units, -k for kernel logs
 - journalctl --since "today"					# log of only the day
 - journalctl -p err						# error logs(-p → Priority = Error and more severe); (0, emerg),(1, alert),(2, crit),(3,err),(4,warning),(5,notice),(6,info),(7,debug)
 - sudo journalctl						# view system level logs

chmod
 - ls -l filename													# list the permissions. First charecter → File type; - = regular file
																	# d = directory l = symbolic link; next 3s → Owner, Group, Others
 - chmod u+x filename												# u → user(owner), g → group, o → others, default → a all, same as no prefix


admins
 - groups															# all 


internals
 - cat /etc/linuxmint/info						# linuxmint is only for mint, for fedora, it has `/etc/fedora-release`
 - cat /etc/os-release
 - cat /etc/issue
 - cat /sys/class/tty/tty0/active				# gives active tty
 - ls /dev/tty*									# gives the list of virtual consoles



ssh
 - ssh-add ~/.ssh/id_ed25519                                                                              # add the key(private key, the public key is added to remote service) to the ssh agent
 - ssh-add -l                                                                                             # list all the added keys to agent. use -L instead for full public key
 - ssh-agent -s                                                                                           # for starting the ssh agent(must use inside eval as → eval "$(ssh-agent -s)")
 - ssh-copy-id -i ~/.ssh/your_key.pub username@server_ip                                                  # copy the public key thorugh ssh itself if you know the system password
 - ssh -i ~/.ssh/mykey user@server_ip                                                                     # use custom key
 - ssh username@your-server-ip										                                                        # connect to a remote linux system(exit	to close a connection). SSH is a systemctl service.
 - ssh-keygen -t ed25519 -C "your_email@example.com" -f ~/.ssh/id_ed25519_personal                        # create an ssh key(private key → ~/.ssh/id_ed25519, public key → ~/.ssh/id_ed25519.pub). Here, the mail is just a label, can use anything.


Tmux
- tmux                                              # create session(Ctrl + B then press D to exit without closing the running program or exit to close)
- tmux attach                                       # attach to a nameless session
- tmux attach -t <session-name>                     # attached to named session  
- tmux new -s <session-name>                        # create a named session
- tmux ls                                           # list all sessions



General
 - Ctrl + Alt + F2(or any F1–F6 key)										# For switching TTY (Terminal Session)															
 - command -v rg															# check if command exists
 - compgen -c									# list all executable commands in path
 - eval "string"                                                                          # execute the string as command(can use the output of command as another command to run)
 - <executable> | tee app.log							# log the standard out to a file while showing it in console(tee -a file.ext to append to the file)
 - which <cli-command-name>                                                 # find the location in the executable(alt: 'whereis')
 - history 												# history of commands executed
 - nl									# number lines, used as `<command> | nl`
 - pwd																		# current working directory
 - sudo kill -9 <PID>
 - sudo netstat -tulnp | grep 22											# find the process running in port 22
 - ss -tulnp								# t → TCP, u → UDP, l → listening, n → numeric(no DNS), p → process details
 - ip addr show																# or `ip address`
 - inxi -S																	# system info
 - less																		# some-command | less → gives walkable console outs
 - lsusb																	# hardwares in USB bus
 - gnome-terminal &															# open new terminal in the linux mint cinnamon(& at the end makes sure the new terminal opens in the background)
 - grep -ir <text> <dir>															# i → case insensitive search, r → recursive
 - sort                                               # sort the output in alphabetical order, used as `<command> | sort`
 - tail -f <file.ext>										# -f → 	watches live, -n 100 → last 100 lines, -F → if file is deleted, auto reopen new
 - tr ':' '\n'											# replace ':' with new line, used in `<command> | tr <params>`
 - type <command/binary/exec>									# handles aliases, shell builtins, functions & binaries
 - uniq                                               # gives the unique lines, -c → count the duplicated, used as `<command> | uniq -c`
 - update-desktop-database ~/.local/share/applications						# refresh your app database
 [file handling]
 - ls -l filename															# basic file information
 - ls lh								# list files with details
 - rm -rf <directory_name>                                                  # remove a directory with all contents(using the -rf option, as it will permanently delete files without any confirmation)
 - mv [options] <source_folder> <destination>                               # move folder
 - mv /path/to/folder /path/to/destination/
 - file filename															# file type
 - find folder/to/work -type f -exec git update-index --no-assume-unchanged {} \;			# f → all files, execute the command after -exec, {} → placeholder for found files, \; → end for command
 - find ~ -name '*text*' 2>/dev/null                                       # 2> means redirect stderr, /dev/null is a 'black hole' that discards anything sent to it
 - find ~dir -type f														# find all in the dir. f → folders, d → directories
 - wc -l filename.txt														# number of lines in a text file
 - wc -l < filename.txt														# number of lines without the filename
 [package managers]
 - dpkg -S /usr/bin/nvim                                                    # finding the package name of binary
 - dpkg -l																	# list all installed packages
 - sudo apt purge <package_name>                                            # uninstall and remove the config/residual files too
 - sudo apt remove <package_name>											# just uninstall
 - uname -m                                                                 # System's architecture
 - apt-cache policy <package-name>                                          # available versions of package
 - apt autoremove
 - apt install ./package.deb												# use with sudo, shold preceed filename with './'
 - apt list																	# installed and available in repos
 - apt list --installed														# list all installed
 - apt list --upgradable
 - apt show <package_name>													# Check available version in APT before installing
 - apt-cache show ripgrep													# the apt show equivalent
 - apt update
 - sudo apt full-upgrade													# upgrade for kernal level packages
 - apt upgrade -y															# -y → 'Yes' for all
 - flatpak list
 - flatpak uninstall --unused
 - flatpak uninstall com.jetbrains.PyCharm-Community						# uninstall with ID
 - readlink -f /snap/bin/firefox											# readlink shows the target of a symlink, -f means “follow the chain of symlinks until you get the real, absolute path.”
 - snap list
 - snap remove app-name
 - dnf config-manager --set-disabled <repo-id> 					# or --set-enabled to toggle
 - dnf check-update
 - dnf downgrade <package>
 - dnf list installed
 - dnf upgrade									# dnf update is same as upgrade
 - dnf info <package>								# --cacheonly to get from local data
 - dnf install <package>
 - dnf reinstall <package>
 - dnf remove <package>
 - dnf repolist all								# list all the remote repos
 - dnf repolist enabled								# or diabled to see only that list
 [fonts]
 - fc-list									# list all fonts
 - fc-cache									# refresh registered fonts(custom fonts are pasted in ~/.local/share/font/)
 [tree]
 - tree																		                                  # show directory stucts in cli
 - tree -L <depth>															# show until that deep of the file structure
 - tree -L 2 --prune -I "node_modules"										# Ignore certain files or directories
 - tree -d -L 2																# only show directories
 [storage]
 - du -sh folder_name														                            # du(Diskusage) -s(total size) -h(human readable)
 - du -h --max-depth=1 folder_name											                    # sizes of all sub dirs inside a folder
 - du -h filename														   # disk usage of file
 - df -h																	                                  # check disk usage
 - baobab																	                                  # gnome disk usage analyzer
 [processes]
 - lsof -i -P -n								# list all listening port processes
 - lsof -i :8080											# Find the Process Using Port 8080
 - ps aux									# list all running processes, a → all users, u → user-orented format(CPU, memory, owner, etc), x → include items not attached to termianl
 - ps -e												# snapshot view of all running processes(-e → show all processes.-f → show full details)
 - ps -p <PID> -f															# details on the one running in PID
 - ps -p <PID> -o cmd														# mode details on process
 - ps -fp <PID>												# even more details
 - pstree <ID>									# process tree( -s → parent process)
																			# u | Show the user who owns the process along with extra details. x | Include processes not attached to a terminal (like background apps, daemons, or GUI apps like IntelliJ)
 - top																		# Live process Monitor(Press P to sort by CPU|M - sort by memory, H - threads|Press k then type a PID to kill a process|Press q to quit)																
 [users]
 - who																		# Who are the users logged in
 - last																		# sign in history
 - w																		# who's logged in, what they're doing, and system load
 [swap file & zram]
 - fallocate -l 8G /swapfile                                                # allocate the swap memory
 - chmod 600 /swapfile                                                      # give permission to system
 - mkswap /swapfile                                                         # make swap file
 - swapon /swapfile                                                         # turn on swap
 - echo '/swapfile none swap defaults 0 0' | sudo tee -a /etc/fstab         # add it to file system table(fstab) to mount on boot
 - swapon --show                                                            # see changes
 - free -h
 [terminals]
 - tty											# gives which tty you're currently on
 - echo "hello from vtty" > /dev/tty3			# writes output to tty3
 [boot]
 - last reboot									# gets all the reboots
 - sudo journalctl -b | grep -i fsck						# File System Consistency Check when abrupt boot/reboot happens

Shell
 - source <filename>                                                        # Reloads the file in question for the shell session(used after editing .bashrc)
 - exec bash                                                                # restart shell(sometimes the shell tries to execute a binary thats long gone due to stale session)
 - ssh -T git@gitlab.com
 - ssh -vT git@gitlab.com



Nano (A text editor in command line)
 - nano filename                                                            # Opens a file, creates if doesnt exist
 - ctrl + o                                                                 # for output
 - ctrl + x                                                                 # Exit nano
 - alt + u                                                                  # Undo
 - alt + e                                                                  # redo
 - ctrl + w                                                                 # search for text (ctrl + w again to find next occurance)
 - ctrl + \                                                                 # Find and Replace
 - ctrl + c                                                                 # Show current cursor position and line number
 - ctrl + _                                                                 # Go to a specific line


NetCat
- nc -v <ip> <port>                                                         # -v for verbose, stays connected for I/O
- nc -zv <ip> <port>-<port>                                                 # -z for zero i/o mode, checks ports inbetween the range
- nc -l -p <port>                                                           # simple tcp listener
- nc <server-ip> <port>                                                     # connect to that listener
- nc -l <port> > received.txt                                                 # On receiver
- nc <receiver-ip> <port> < file.txt                                          # On sender

Nmap
- nmap -Pn -p <s_port>-<e_port> <ip>                                        # scan there port to see whats open


Java
 - update-alternatives --list java                                          # List outs all the java versions installed. Change Affects Only Java Commands (Not JAVA_HOME). 
																			# does NOT update the JAVA_HOME environment variable, which some programs (like Gradle, Maven, and Tomcat) rely on.
																			# after using update-alternatives, we often manually set JAVA_HOME in .bashrc or .profile
 - update-alternatives --config java                                        # change the default java version(have to be done as a super user)
 - export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre                   # For setting java home for the current terminal session.
 - export PATH=$JAVA_HOME/bin:$PATH											# used after the above
 - source ~/.bashrc															                            # to refresh current session shell script


Cloc
 - cloc path/to/dir													                  # count number of lines of code, comment, md, etc
 - cloc path/to/file													                # count in one file
 - cloc path/to/dir --json > report.json								      # export into json, can also use --csv
 - cloc --include-ext=js path/to/dir									        # for a specific extension, can also include multiple with '--include-ext=java,xml'
 - cloc path/to/dir --exclude-dir=node_modules,dist								# --ignored=ignored_files.txt → for the list of ignored files


git commands
  - git add -N .															# For untracked files, you can first add them to the staging area temporarily
  - git add -p <filename>													# lets you review each "hunk" in the file and choose what to stage(y - to stage the hunk, n to skip, s to split the hunk, q to quit)
  - git am <file-name>														# ammend the patch file(usually .patch or .eml) (includes all metadata)
  - git log <branch-name>                                                   # list commits of a certain branch
  - git log --pretty=full													# author and commiter
  - git log --oneline --graph --all --decorate								# --all → Shows commits from all branches, not just the current one(Without this, you’d only see commits reachable from HEAD), --decorate → Adds branch and tag names
  - git commit --amend --reset-author										# resets the author of last commit
  - git status --untracked-files=all										# all the trackable files inside untracked directory
  - git show                                                                # Last commits changes (full details)
  - git show <commit-hash>                                                  # specific commit changes (full details)
  - git show --name-only <commit-hash>                                      # just names of files with changes
  - git show --stat <commit-hash>                                           # names plus line changes stat
  - git log --oneline                                                       # Concise commit details
  - git log -n 5															# log top 5 commits
  - git show <commit-hash> -- <file-path>                                   # certain file from a certain commit (file path should be absolute)
  - git diff                                                                # All file changes
  - git diff <file-path>                                                    # specific file changes
  - git diff --cached                                                       # changes stagged for commit
  - git diff --word-diff=color                                              # diff on word change level
  - git diff > changes.diff													                        # Redirects the output of git diff to a file named changes.diff - can later be reapplied to your repository to restore those changes.
  - git diff stash@{0}														# See the full diff of a stash
  - git diff <root-branch>..<feat-branch>									# file changes in feat that are not in root
  - git apply changes.diff													                        # Apply the changes from the file changes.diff
  - git shortlog -s -n                                                      # number of commit by each author(-s → summarized, -n → numbered)
  - git stash push -m "message"
  - git stash push -- file1.ext file2.ext
  - git stash push -m "message" --keep-index                                # stash tracked & unstaged changes
  - git stash push --staged                                                 # stash only the indexed(staged) changes
  - git stash -u															# -u is short for --include-untracked
  - git stash -a															# -a is short for --all, which includes untracked and ignored files
  - git stash list
  - git stash show -p stash@{0}												# Show changes in a specific stash, The -p flag (or --patch) shows the detailed changes.
  - git stash apply stash@{0}												# apply changes but keep it in the stash list
  - git stash clear                                                         # remove all stash
  - git stash drop stash@{n}                                                # remove a specific stash
  - git stash show -p --include-untracked stash@{0}							# Show a stash in detail (including untracked files if any)
  - git stash show -p stash@{0} > stash_patch.diff							# the changes from the stash, pack it into a diff file(useful in manually applying the changes if more than one stash has changes in same file)
  - git cherry-pick <commit-hash>                                           # Add a certain commit from another branch to this branch
  - git cherry-pick --continue                                              # complete the current cherry-pick
  - git cherry-pick <start-commit>^..<end-commit>                           # Cherry-Pick Multiple Commits
  - git cherry-pick abc1234 def5678 ghi91011
  - git checkout -b new-branch												# creates and checkout if it doesn't exist(-b "branch", -c "create")(alternatively `git switch -c new-branch`)
  - git checkout -b branch-name tag-name									# create a new branch with the tag's commit at head.(Commit hash can also be used)
  - git checkout --orphan new-branch-name									# create a branch that is not originated from any other branch(no history)
  - git blame <filename.ext>                                                # print blame for a file
  - git blame -L 20,50 <filename>                                           # blame on specific lines
  - git blame <commit-hash>^ -- <filename>                                  # blame using previous version of file
  - git branch                                                              # all branches that exist locally
  - git branch -m main														                          # rename master branch to main after init
  - git branch -r                                                           # all branches at remote repo
  - git branch -a                                                           # at both remote and local
  - git branch -vv															# brances with remote links
  - git branch --format="%(refname:short)"                                  # Compact View
  - git branch --show-current
  - git branch --unset-upstream												# remove the upstream link
  - git branch --merged <target-branch>										# branches that are merged to target through merge or rebase
  - git bundle create --progress <name.bundle> --all							# create a portable file of the whole git repo, --progress to log steps, --all for all refs(branches, tags, remote tracking branches)
  - git clone --branch <branch-name> --single-branch <repository-url>       # specifically clone one branch from a remote repo
  - git clone --recurse-submodules https://github.com/example/repo.git		# ensures that all submodules are also cloned and initialized in one step
  - git rm <file-path> 														# remove tracked files
  - git rm -r --cached target/												                      # This ensures that target folder is ignored going forward, and any previously tracked files in target are removed from the repository.
  - git reset --hard														                            # Discard all changes and reset the working directory
  - git reset --soft HEAD~1													                        # Undo Last Commit but Keep Changes (Soft Reset)
  - git restore																# restore the changes back as in the HEAD commit
  - git restore --staged .													                        # unstage all files
  - git rebase main															# Updates your branch to match the latest state of <target-branch>
  - git clean -f															                              # if tracked, git doesn't remove it
  - git clean -fd															                              # files n directories
  - git clean -fx															                              # remove ignorted files too
  - git clean -fdx															                            # ignored and untracked files and directories
  - git clean -n															                              # (dry run)preview before deleting
  - git clone --branch <branch-name> --single-branch <repo-url>
  - git config --get user.name
  - git config --get user.email
  - git config --global push.autoSetupRemote true				# set up the remote branch automatically if it doesnt exist
  - git config --global --unset <variable_name>                             # remove a global varible
  - git config --global --list
  - git remote                                                              # list remote repos
  - git remote -v															                              # show remote repo links
  - git remote add <remote_name> <remote_url>                               # add a remote URL
  - git remote set-url origin git@github.com:RicardoVercetti/Des3FromScratch.git						# change to ssh URL, HTTP looks t
  - git remote prune origin																				# removes stale remote-tracking branches from your local repository
  - ssh -T git@github.com													                          # check ssh connection w/ github
  - git branch --contains <commit-hash>										                  # check if a specific commit exists in any branch of a Git repository
  - git branch -r --contains <commit-hash>									# if remote contains the commit
  - git fetch origin <branch-name>											                    # fetch only one branch changes
  - git fetch --all
  - git fetch --prune														# prune/remove missing branches comparing remote while fetching
  - git format-patch -1 <commit-hash>										# -1 (short for --max-count=1) tells Git to create a patch for only one commit
  - git format-patch -3 HEAD												# patch file for top 3 commits
  - git push -u origin main													                        # -u(--set-upstream)
  - git push -f																# force push
  - git push --force-with-lease												# This checks if the remote branch has new commits before forcing the push. It prevents accidental overwrites if someone else has pushed changes
  - git push origin v1.2.0													# push one tag(By default, git push doesn’t push tags)
  - git push origin --tags													# push all local tags
  - git rev-list --count HEAD                       # count the number of commits(can also use branch name)
  - git rev-list --left-right --count origin/main...main					# Compare Local and Remote Directly
  - git log main..origin/main --oneline										# if remote has new commits comparing local
  - git log origin/main..main --oneline 			# local has no new compaing remote 
  - git pull origin <current-branch>										# pull only one branch changes
  - git pull --rebase														# puts the local commits on top of pulled remote commits
  - git rm -r --cached the/folder											# To remove the folder/file from tracking while keeping them locally
  - git update-index --assume-unchanged file/location						# pause tracking changes, ignore anymore changes without altering the remote file
  - git ls-files -v															# lists all tracked files along with their status.
  - git ls-files -v | grep '^[[:lower:]]'									# find all tracked files with lower 'h' - assume unchanged
  - git ls-files --others --exclude-standard								# shows all files not currently tracked by Git and not ignored via .gitignore
  - git ls-remote --heads origin											# list remote upstreams
  - git submodule update --init --recursive									# If you forgot to use --recurse-submodules, you can still get the submodules later with this
  - git submodule status													# check if project has any submodules
  - git submodule foreach --recursive 'echo $path'							# print path of each submodule
  - git tag																	# list all tags
  - git tag v1.2.0															# adds a lightweight tag to HEAD
  - git tag v1.2.0 abc1234													# tag a specific commit
  - git tag -a v1.2.0 -m "Release v1.2.0"									# annotated tag
  - git worktree add path/to/folder branch-name                            # branch name itself is optional, can also use '-b new-branch'
  - git worktree remove path/to/folder

Git-plugins
 - git config --global core.pager delta                                 # gotta install git-delta first
 - git config --global interactive.diffFilter delta
 - git config --global delta.navigate true
 - git config --global delta.side-by-side true                          # override the inline diff with side-by-side
 - git config --global delta.light true                                 # optional for a lighter theme 




sqlcmd
 - sqlcmd -?                                                            # to check if its installed
 - sqlcmd -S <server_name> -U <username> -P <password>
 - sqlcmd -S <server> -U <user> -P <pass> -d <database> -i <file.sql>   # For query with file

sqlite
 - .databases
 - .headers on												# enable column names
 - .mode column												# pad for readability
 - .mode csv
 - sqlite3 name.db											# open db, or create if it doesn't exist
 - .quit														# close the CLI
 - .schema													# all table schemas
 - .schema <table_name>										# schema of one table
 - sqlite3 mydb.sqlite .dump > backup.sql					# export to sql
 - sqlite3 newdb.sqlite < backup.sql							# restore
 - .tables

MVN
 - mvn compile
 - mvn test
 - mvn package
 - mvn clean
 - mvn validate

sdkman!
 - sdk list
 - sdk list java | grep -E '\installed'											# list installed versions
 - sdk install <candidate>													# candidate can be maven, gradle, java, etc.,
 - sdk use <candidate> <version>											# switch between versions
 - sdk version

Firewall
 - ufw enable														# enable the firewall
 - ufw status
 - ufw allow 8089/tcp
 - ufw status verbose													# Detailed status
 - ufw reload															# After making changes, reload the firewall to take effect (never needed this though)


storage analyzer
 - ncdu /

Gradle
 - gradle --version
 - ./gradlew dependencies													# download dependencies without building
 - ./gradlew bootRun														# run the project
 - ./gradlew build --refresh-dependencies									# force gradle to redownload dependencies
 - gradle --stop  															# Stop any running Gradle daemons
 - gradlew test --info												# run with debug info of gradle process
 - gradlew test --rerun-tasks											# ignored cache and reruns
 - gradle clean
 - rm -rf ~/.gradle/caches/													# remove cache files
 - gradle init --type basic													# for a root multi module project
 - ./gradlew tasks															# list tasks available

Rustup
 - rustup component list --installed									# things like clippy, fmt
 - rustup show												# show toolchains & targets
 - rustup targer list --installed
 - rustup toolchain list										# list all toolchains
 
Cargo
 - cargo build															# compile without running
 - cargo build --release													# produce optimized build
 - cargo check 																# check project for errors
 - cargo clean															# removes '/target' folder
 - cargo clippy --fix														# auto fix as per linter suggestions(git state must be before running this)
 - cargo info <package-name>
 - cargo install <package-name>											# installs a global binary
 - cargo new project_name													# create new rust project with cargo build tool
 - cargo run																# run the project
 - cargo search <package-name>
 
 
npm
 - npm install -g typescript												# globally install tsc
 - npm install -g ts-node													# globally install the one-go compiler and runner
 - ts-node filename.ts														# to compile and run .ts files
 - tsc --init																# the tsconfig.json is required for running even a random file
 - npm list									# list all the installed packages
 - npm list -g									# global packages
 - npm list --depth=0								# only direct dependencies

nvim
 - shift + esc                                        # mode change to normal
 - :w                                                 # write the changes
 - :q                                                 # quit
 - :q!                                                # exit without saving
 - :wq                                                # save and quit
 - q                                                  # quit Lazy.nvim
 - h                                                  # home

emacs
 - C-x C-c											# exit
 - C-y												# paste
 - C-x u												# undo
 - C-x C-s											# save buffer to file

kafka
 - bin/zookeeper-server-start.sh config/zookeeper.properties				# start zoo keeper
 - bin/kafka-server-start.sh config/server.properties						# start kafka broker

docker
 - docker build -t <app-nick-name> .										# make a docker image from Dockerfile
 - docker exec -it <container> bash											# Open a shell inside a running container(exit → to close)
 - docker images															# all available images
 - docker logs <container_id_or_name>
 - docker ps																# running containers (-a → all incl stopped)
 - docker pull <img-name>													# pull from docker hub
 - docker rm <container>													# Remove a stopped container
 - docker rmi <image>														# remove an image
 - docker run <id>															# run a container(-d → detached mode)(docker run -p 5001:5001 <image_name>)
 - docker start <container>													# Restart a stopped container
 - docker stop <container-id>     											# Stop the container
 - docker system prune														# Remove stopped containers, unused images, and networks( -a → Remove all unused images (not just dangling ones)
 - docker run -d --name pg17 -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin123 -e POSTGRES_DB=mydb -p 5432:5432 postgres:17		# spin up the postgres container


postgres
 - createdb -U postgres -h localhost -p 5431 <db_name>												# create a new empty database
 - pg_dump -U your_username -h localhost -p 5432 your_database > backup.sql							# backup into sql file
 - psql -h localhost -p 5432 -U your_username -d your_database										# connect to the database(`\q` or `quit` → to quit)
 - psql -U postgres -h localhost -p 5431 -d <db_name> -f backup.sql									# restore the sql(db_name should already exist)
 - pg_restore -U postgres -h localhost -p 5432 -d <db_name> filename.sql							# restore a custom postgres dump



docker-associated
 - sudo usermod -aG docker $USER											# add user to docker group(usermod → A command to modify user accounts in Linux)
 - newgrp docker															# refresh group permissions in the current shell session
 

arch-linux
[packages]
 - pacman -Ss <package-name>												# search for packages
 - pacman -Q													# list all packages(official repos + AUR)
 - pacman -Qe													# explicitly installed
 - pacman -Qi <package-name>                        # search for the package with the specific name
 - pacman -Qm													# only AUR packages
 - pacman -Qo /usr/bin/executable										# tells which package owns the binary
 - pacman -Qs <package-name>												# search installed packages(pacman -Qs "^sl$", ^ → matches the start of the string, $ → matches the end of the string)
 - pacman -Qu													# list upgradable packages
 - pacman -Sy													# update package database
 - pacman -Syu													# both package database and installed packages
 - pacman -S <package-name>											# install the package
 - pacman -S <package-name>=<version> 										# install a specific version
 - pacman -R <package-name>											# remove packages
 - pacman -Rns <package-name>											# Remove with unused dependencies
 - pacman -Rns $(pacman -Qtdq)											# remove all orphan packages
 - pacman -Qtdq 												# Q - query, t - list unrequired, d - list dependencis, q - quiet(just package names)	

[display]
 - brightnessctl set +10%  # increase brightness
 - brightnessctl set 10%-  # decrease brightness
[hyprland]
 - hyprctl reload
 
 
LLC(low level code)
 - gcc -c <file.c>										# create an object(.o) file from the .c file
 - gcc <file1.o> <file2.o> -o <main>						# link the object files to create a single binary
 - gcc <filename> -o <outfilename>						# compile and link the c code in one go
 - gcc -g hello.c -o hello_debug							# compile with debug symbols
 - gcc -o0 <filename> -o <outfilee>						# no optimization(default), others → -O1(basic), -O2(strong, safe), -O3(very aggressive, may increase size), -Os(smaller binary size), -Og(optimized but debuggable)
 - objdump -d <binfile>									# assembly code of binary
 - xxd <filename>										# print the hex dump of the binary
 

Variables
 - $$ 								# current process
 - $TERM							# describes the type of terminal interface your shell is using
 - $TERM_PROGRAM						# terminal program name
 - <command_1> $(<command_2>)					# output of command_2 as input of command_1
